package graph.standard.weighted;

import graph.standard.Node;

import java.util.List;
import java.util.Map;

/**
 * Models the cost of a path
 * @author CreeperStone72
 */
public class Cost {
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constants //////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    private static final double INFINITY = Double.POSITIVE_INFINITY;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Attributes /////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * How much does it cost to go from the previous node ?
     */
    private double cost;

    /**
     * What node am I starting from ?
     */
    private Node<?> origin;

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Empty constructor
     * Sets the cost to positive infinity with no origin
     */
    public Cost() { this(INFINITY); }

    /**
     * Partial constructor
     * The cost has no origin
     * @param cost is the cost to get to a node
     */
    public Cost(double cost) { this(cost, null); }

    /**
     * Main constructor
     * @param cost is the cost to get to a node
     * @param origin is the starting node
     */
    public Cost(double cost, Node<?> origin) {
        setCost(cost);
        setOrigin(origin);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Setters ////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    public void setCost(double cost) { this.cost = cost; }

    public void setOrigin(Node<?> origin) { this.origin = origin; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Getters ////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    public double getCost() { return cost; }

    public Node<?> getOrigin() { return origin; }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Methods ////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    /**
     * Finds the node with the smallest cost
     * @param costs is the list of nodes and costs
     * @return the node with the smallest cost
     */
    public static <T> Node<T> findMin(Map<Node<T>, Cost> costs, List<Node<T>> alreadyVisited) {
        Node<T> result = null;
        Cost costMin = new Cost();

        for(Map.Entry<Node<T>, Cost> entry : costs.entrySet()) {
            if(entry.getValue().getCost() < costMin.getCost() && !alreadyVisited.contains(entry.getKey())) { result = entry.getKey(); }
        }

        return result;
    }

    @Override
    public String toString() { return getCost() + ((getOrigin()!= null) ? "_" + getOrigin() : ""); }
}
